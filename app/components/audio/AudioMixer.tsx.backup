'use client';

import React, { useRef, useEffect, useState, useCallback } from 'react';

export interface MixerChannel {
  id: string;
  name: string;
  volume: number;
  pan: number; // -1 (left) to 1 (right)
  mute: boolean;
  solo: boolean;
  effects: {
    reverb: { enabled: boolean; amount: number };
    delay: { enabled: boolean; time: number; feedback: number };
    filter: { enabled: boolean; frequency: number; resonance: number };
  };
}

export interface AudioMixerProps {
  channels: MixerChannel[];
  masterVolume: number;
  onChannelChange?: (channelId: string, updates: Partial<MixerChannel>) => void;
  onMasterVolumeChange?: (volume: number) => void;
  className?: string;
}

const AudioMixer: React.FC<AudioMixerProps> = ({
  channels,
  masterVolume,
  onChannelChange,
  onMasterVolumeChange,
  className = ''
}) => {
  const audioContextRef = useRef<AudioContext | null>(null);
  const masterGainRef = useRef<GainNode | null>(null);
  const channelGainsRef = useRef<Map<string, GainNode>>(new Map());
  const channelPannersRef = useRef<Map<string, StereoPannerNode>>(new Map());
  const [isInitialized, setIsInitialized] = useState(false);

  // Initialize AudioContext and create audio nodes
  const initializeAudioContext = useCallback(async () => {
    if (!audioContextRef.current) {
      audioContextRef.current = new (window.AudioContext || (window as any).webkitAudioContext)();
      
      if (audioContextRef.current.state === 'suspended') {
        await audioContextRef.current.resume();
      }

      // Create master gain node
      masterGainRef.current = audioContextRef.current.createGain();
      masterGainRef.current.gain.setValueAtTime(masterVolume, audioContextRef.current.currentTime);
      masterGainRef.current.connect(audioContextRef.current.destination);

      setIsInitialized(true);
    }
  }, [masterVolume]);

  // Create audio nodes for channels
  const createChannelNodes = useCallback((channel: MixerChannel) => {
    if (!audioContextRef.current || !masterGainRef.current) return;

    // Create gain node for volume control
    const gainNode = audioContextRef.current.createGain();
    gainNode.gain.setValueAtTime(channel.volume, audioContextRef.current.currentTime);
    
    // Create stereo panner for pan control
    const pannerNode = audioContextRef.current.createStereoPanner();
    pannerNode.pan.setValueAtTime(channel.pan, audioContextRef.current.currentTime);

    // Connect: source -> gain -> panner -> master
    gainNode.connect(pannerNode);
    pannerNode.connect(masterGainRef.current);

    channelGainsRef.current.set(channel.id, gainNode);
    channelPannersRef.current.set(channel.id, pannerNode);
  }, []);

  // Update channel volume
  const updateChannelVolume = useCallback((channelId: string, volume: number) => {
    const gainNode = channelGainsRef.current.get(channelId);
    if (gainNode && audioContextRef.current) {
      gainNode.gain.setValueAtTime(volume, audioContextRef.current.currentTime);
    }
  }, []);

  // Update channel pan
  const updateChannelPan = useCallback((channelId: string, pan: number) => {
    const pannerNode = channelPannersRef.current.get(channelId);
    if (pannerNode && audioContextRef.current) {
      pannerNode.pan.setValueAtTime(pan, audioContextRef.current.currentTime);
    }
  }, []);

  // Update master volume
  const updateMasterVolume = useCallback((volume: number) => {
    if (masterGainRef.current && audioContextRef.current) {
      masterGainRef.current.gain.setValueAtTime(volume, audioContextRef.current.currentTime);
    }
  }, []);

  // Initialize on mount
  useEffect(() => {
    initializeAudioContext();
  }, [initializeAudioContext]);

  // Create nodes for all channels
  useEffect(() => {
    if (isInitialized) {
      channels.forEach(createChannelNodes);
    }
  }, [isInitialized, channels, createChannelNodes]);

  // Update channel volumes when they change
  useEffect(() => {
    channels.forEach(channel => {
      updateChannelVolume(channel.id, channel.volume);
      updateChannelPan(channel.id, channel.pan);
    });
  }, [channels, updateChannelVolume, updateChannelPan]);

  // Update master volume
  useEffect(() => {
    updateMasterVolume(masterVolume);
  }, [masterVolume, updateMasterVolume]);

  const handleChannelVolumeChange = useCallback((channelId: string, volume: number) => {
    onChannelChange?.(channelId, { volume });
  }, [onChannelChange]);

  const handleChannelPanChange = useCallback((channelId: string, pan: number) => {
    onChannelChange?.(channelId, { pan });
  }, [onChannelChange]);

  const handleChannelMute = useCallback((channelId: string, mute: boolean) => {
    onChannelChange?.(channelId, { mute });
  }, [onChannelChange]);

  const handleChannelSolo = useCallback((channelId: string, solo: boolean) => {
    onChannelChange?.(channelId, { solo });
  }, [onChannelChange]);

  const handleMasterVolumeChange = useCallback((volume: number) => {
    onMasterVolumeChange?.(volume);
  }, [onMasterVolumeChange]);

  return (
    <div className={`audio-mixer p-6 border rounded-lg bg-gray-900 text-white ${className}`}>
      <div className="flex justify-between items-center mb-6">
        <h2 className="text-2xl font-bold">Audio Mixer</h2>
        <div className="flex items-center space-x-4">
          <span className="text-sm text-gray-400">
            {channels.length} channels | {isInitialized ? 'Ready' : 'Initializing...'}
          </span>
        </div>
      </div>

      {/* Master Controls */}
      <div className="mb-6 p-4 bg-gray-800 rounded">
        <h3 className="text-lg font-semibold mb-4">Master Controls</h3>
        
        <div className="flex items-center space-x-6">
          <div className="flex-1">
            <label className="block text-sm font-medium mb-2">
              Master Volume: {(masterVolume * 100).toFixed(0)}%
            </label>
            <input
              type="range"
              min="0"
              max="1"
              step="0.01"
              value={masterVolume}
              onChange={(e) => handleMasterVolumeChange(parseFloat(e.target.value))}
              className="w-full"
            />
          </div>
          
          <div className="text-center">
            <div className="w-16 h-16 bg-gray-700 rounded-full flex items-center justify-center">
              <span className="text-2xl font-bold">
                {(masterVolume * 100).toFixed(0)}%
              </span>
            </div>
          </div>
        </div>
      </div>

      {/* Channel Strips */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
        {channels.map((channel) => (
          <div key={channel.id} className="channel-strip p-4 bg-gray-800 rounded">
            <div className="flex items-center justify-between mb-3">
              <h4 className="font-medium text-sm">{channel.name}</h4>
              <div className="flex space-x-1">
                <button
                  onClick={() => handleChannelMute(channel.id, !channel.mute)}
                  className={`px-2 py-1 rounded text-xs ${
                    channel.mute ? 'bg-red-600' : 'bg-gray-600'
                  }`}
                >
                  M
                </button>
                <button
                  onClick={() => handleChannelSolo(channel.id, !channel.solo)}
                  className={`px-2 py-1 rounded text-xs ${
                    channel.solo ? 'bg-yellow-600' : 'bg-gray-600'
                  }`}
                >
                  S
                </button>
              </div>
            </div>

            {/* Volume Fader */}
            <div className="mb-4">
              <label className="block text-xs font-medium mb-2">
                Volume: {(channel.volume * 100).toFixed(0)}%
              </label>
              <div className="relative">
                <input
                  type="range"
                  min="0"
                  max="1"
                  step="0.01"
                  value={channel.volume}
                  onChange={(e) => handleChannelVolumeChange(channel.id, parseFloat(e.target.value))}
                  className="w-full h-32 -rotate-90 origin-center"
                  style={{ transform: 'rotate(-90deg)' }}
                />
                <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                  <div className="w-1 h-24 bg-gray-600 rounded"></div>
                </div>
              </div>
            </div>

            {/* Pan Control */}
            <div className="mb-4">
              <label className="block text-xs font-medium mb-2">
                Pan: {channel.pan > 0 ? `R${(channel.pan * 100).toFixed(0)}` : 
                      channel.pan < 0 ? `L${Math.abs(channel.pan * 100).toFixed(0)}` : 'C'}
              </label>
              <input
                type="range"
                min="-1"
                max="1"
                step="0.01"
                value={channel.pan}
                onChange={(e) => handleChannelPanChange(channel.id, parseFloat(e.target.value))}
                className="w-full"
              />
            </div>

            {/* Effects */}
            <div className="space-y-2">
              <div className="flex items-center space-x-2">
                <input
                  type="checkbox"
                  checked={channel.effects.reverb.enabled}
                  onChange={(e) => onChannelChange?.(channel.id, {
                    effects: {
                      ...channel.effects,
                      reverb: { ...channel.effects.reverb, enabled: e.target.checked }
                    }
                  })}
                  className="rounded"
                />
                <label className="text-xs">Reverb</label>
              </div>
              
              <div className="flex items-center space-x-2">
                <input
                  type="checkbox"
                  checked={channel.effects.delay.enabled}
                  onChange={(e) => onChannelChange?.(channel.id, {
                    effects: {
                      ...channel.effects,
                      delay: { ...channel.effects.delay, enabled: e.target.checked }
                    }
                  })}
                  className="rounded"
                />
                <label className="text-xs">Delay</label>
              </div>
              
              <div className="flex items-center space-x-2">
                <input
                  type="checkbox"
                  checked={channel.effects.filter.enabled}
                  onChange={(e) => onChannelChange?.(channel.id, {
                    effects: {
                      ...channel.effects,
                      filter: { ...channel.effects.filter, enabled: e.target.checked }
                    }
                  })}
                  className="rounded"
                />
                <label className="text-xs">Filter</label>
              </div>
            </div>

            {/* Channel Status */}
            <div className="mt-3 pt-2 border-t border-gray-700">
              <div className="flex items-center justify-between text-xs">
                <span className={channel.mute ? 'text-red-400' : 'text-green-400'}>
                  {channel.mute ? 'MUTED' : 'ACTIVE'}
                </span>
                <span className={channel.solo ? 'text-yellow-400' : 'text-gray-400'}>
                  {channel.solo ? 'SOLO' : ''}
                </span>
              </div>
            </div>
          </div>
        ))}
      </div>

      {/* Mixer Summary */}
      <div className="mt-6 p-4 bg-gray-800 rounded">
        <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
          <div>
            <span className="text-gray-400">Active Channels:</span>
            <span className="ml-2 font-medium">
              {channels.filter(c => !c.mute).length}
            </span>
          </div>
          <div>
            <span className="text-gray-400">Solo Channels:</span>
            <span className="ml-2 font-medium">
              {channels.filter(c => c.solo).length}
            </span>
          </div>
          <div>
            <span className="text-gray-400">Reverb Active:</span>
            <span className="ml-2 font-medium">
              {channels.filter(c => c.effects.reverb.enabled).length}
            </span>
          </div>
          <div>
            <span className="text-gray-400">Delay Active:</span>
            <span className="ml-2 font-medium">
              {channels.filter(c => c.effects.delay.enabled).length}
            </span>
          </div>
        </div>
      </div>
    </div>
  );
};

export default AudioMixer;
